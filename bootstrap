#!/usr/bin bash


# set the directory where this is installed to
export ENVIRONMENT_LOCATION=`dirname $0`

export USER_MODULES=$ENVIRONMENT_LOCATION/users

export SOURCE_UTILS=$ENVIRONMENT_LOCATION/modules/00_env_tools

function set_zsh_options(){
    # let aliases be re-autocompleted by zsh
    #setopt complete_aliases

    # dont have directories auto named by their variables
    # http://stackoverflow.com/a/17104442/310196
    unsetopt auto_name_dirs
}

if [ "$SHELL" = "/bin/zsh" ]; then
  set_zsh_options

  fpath=($ENVIRONMENT_LOCATION/zsh_completions/**/ $fpath)
else
  shopt -s globstar
fi

no_color='\033[0m' # No Color
yellow='\033[0;33m'
red='\033[0;31m'
cyan='\033[0;36m'

function log-info(){
	log-color $cyan "$@"
}

function log-warn(){
	log-color $yellow "$@"
}

function log-error(){
	log-color $red "$@"
}

function log-color(){
	color=$1

	shift

	echo -e "${color}$@${NC}"
}

_ensure_json_config() {
    local config_file=$ENVIRONMENT_LOCATION/.config.json

    if [ ! -f $config_file ]; then
        echo '{}' > $config_file
    fi
}

json_set_pref() {
    local config_file=$ENVIRONMENT_LOCATION/.config.json

    _ensure_json_config

    if [ $# -eq 3 ]; then
        local Category=$1
        local Setting=$2
        local Value=$3
    elif [ $# -eq 2 ]; then
        local Category='general_settings'
        local Setting=$1
        local Value=$2
    else
        log-error 'Not enough args!'
        return
    fi

    settings=$(jq ".\"$Category\".\"$Setting\" = \"$Value\"" $config_file)

    if [ $? -eq 0 ]; then
        echo $settings >! $config_file
    fi
}

_clean_old_config() {
    local config_file=$ENVIRONMENT_LOCATION/.config
    if [ -f $config_file ]; then
        rm $config_file
    fi
}

_migrate_old_config() {
    local config_file=$ENVIRONMENT_LOCATION/.config

    if [ -f $config_file ]; then
        log-info 'Found old config, migrating to json config'

        _migrate_to_json() {
            while read data; do
                if [ -z $data ]; then
                    continue
                fi
                local -a args
                args=(${=data})
                log-info "Migrating setting key: '${args[1]}' value: '${args[2]}'"
                json_set_pref $args
            done
        }

        awk -F ':' '{ print $1, $2 }' $config_file | _migrate_to_json
        json_settings

        # _clean_old_config
    fi
}

json_settings() {
    local config_file=$ENVIRONMENT_LOCATION/.config.json
    _ensure_json_config

    jq "." $config_file
}

json_get_pref() {
    local config_file=$ENVIRONMENT_LOCATION/.config.json
    _ensure_json_config

    if [ $# -eq 2 ]; then
        local Category=$1
        local Setting=$2
    elif [ $# -eq 1 ]; then
        local Category='general_settings'
        local Setting=$1
    else
        log-error 'Not enough args!'
        return
    fi

    jq ".\"$Category\".\"$Setting\" // \"\"" $config_file | sed 's/^"//' | sed 's/"$//'
}

function _reset_pref(){
    local pref=$1

    json_set_pref "$pref" ""
}

function _setpref(){
    json_set_pref $1 $2
}

function _readpref(){
    json_get_pref $1
}

function install-default-editor(){
    edit_pref=`_readpref "editor"`

    if [ -z $edit_pref ] && ! hash atom 2>/dev/null; then
        log-warn "Would you like to install a default user editor? Atom is free and can be installed with cask"
        log-warn "If you would like to install this? It is recommended (y/n)"

        read installAtom

        if [ $installAtom = "y" ]; then
            brew cask install atom
            _setpref "editor" "y"
        else
            _setpref "editor" "n"
        fi
    fi
}

function install-yadr(){
    ### install yadr, at least ask once
    if [ ! -d $HOME/.yadr ]; then

        install_pref=`_readpref "yadr"`

        if [ -z $install_pref ]; then
            log-warn "Missing yadr.  YADR (yet another dot file repo) is incredibly useful. Do you want to install it? Your preference will be rememembered (y/n)"

            read installYadr

            if [ $installYadr = "y" ]; then
                sh -c "`curl -fsSL https://raw.githubusercontent.com/skwp/dotfiles/master/install.sh`"
            else
                _setpref "yadr" "n"
            fi
        fi;
    fi
}

function install-brew-cask(){
    # install cask binary installer https://github.com/caskroom/homebrew-cask
    cask_installed=`brew cask`

    if [ "$?" != "0" ]; then
        log-warn "Cask not installed, installing..."

        brew install caskroom/cask/brew-cask
    fi;
}

function ensure_jq() {
    # command line json parsing
    hash jq 2>/dev/null || { brew install jq }
}

function install-prereqs(){
    hash python 2>/dev/null || { brew python }

    hash pip 2>/dev/null || { sudo easy_install pip }

    hash wget  2>/dev/null || { brew install wget }

    install-yadr

    install-brew-cask

    install-default-editor
}


function load-basic-modules(){
  find $ENVIRONMENT_LOCATION/modules -type f -iname '*.zsh' -print0 | while IFS= read -r -d $'\0' module_file; do
        log-info "Loading $module_file"
        . $module_file
  done
}

function load-user-modules(){
    userModulePath=$ENVIRONMENT_LOCATION/users

    if [ -d $userModulePath ]; then
        ## follow all sym links and load all the files
        ## (.N) is the zsh global identifier to suppress no results
        for module_file in `ls -1LRd $userModulePath/*/*.sh(.N)`;
        do
            name=`basename $module_file`

            if [[ -f $module_file && $name != "validate.sh" ]]; then
                log-info "Loading user module $module_file"

                USER_MODULE_PATH=`dirname \`get_abs_filename $module_file\``

                source $module_file
            fi
        done

        # once they are all loaded, run the validation

        for validation_file in `ls -1LRd $userModulePath/*/validate.sh(.N)`;
        do
            if [ -f $validation_file ]; then
                log-info "Executing validation on user module $module_file"

                USER_MODULE_PATH=`dirname \`get_abs_filename $validation_file\``

                source $validation_file
            fi
        done
    fi
}

function load-source-path(){
    if [ -z $SRC_DIR ]; then
        srcpath=`_readpref "src-path"`

        if [ -z $srcpath ]; then
            log-warn "Source path isn't defined!"
            log-warn "What is the path where your source code is defined? For example '~/documents/sourecode'?"
            read srcpath

            srcpath=`echo $srcpath | sed "s;~;$HOME;"`

            _setpref "src-path" $srcpath
        fi

        export SRC_DIR=$srcpath
    fi;
}

function set-permissions(){
    chmod +x $ENVIRONMENT_LOCATION/modules/scripts/git-diffall
}

function validate(){
    log-info "READY"
}

# install jq for config
ensure_jq

# migrate the old .config file to json if needed
_migrate_old_config

# make sure the source code dir is set
load-source-path

# load up any pending required installables
install-prereqs

# load basic modules
load-basic-modules

set-permissions

# load user modules
load-user-modules

# reload compinit now that everything is loaded up
# so that the updated $fpath variable's folders get
# read. this lets the custom zsh_completions folder
# get leveraged
reload-compinit

# final validation
validate

if [ "$1" = "bash" ]; then
  log-info "Path logged to ~/.paths"
  echo $PATH >! ~/.paths

  rm -rf ~/.aliases

  while read -r line; do
    echo "alias ${line}" >> ~/.aliases
  done <<< `alias | grep '='`
fi
